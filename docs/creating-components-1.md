# Creating Components Part 1: Starting the MathSender

## Background 

Components are the lifeblood of an F' deployment. In this tutorial the components are strickly virtual, however in many deployments components will represent unique pieces of hardware, such as sensors and microcontrollers! 

## In this section 

In this section, you will begin creating an active component
and write its F Prime Prime (fpp) implementation. You will generate
cpp and hpp files using the fpp. Note, that you will implement component behavior in `MathSender.cpp` in the 
next section. 


## Setup

Start by creating and navigating to the directory where the components will live: 

```shell 
# In: MathProject
mkdir Components
cd Components 
```

## Component Description 
@TODO (Make a better description)
The `MathSender` is an active component which receives parameters, sends parameters, logs events, and sends telemetry. 

With the component description in mind, use the following command to create the `MathSender` component:

## Creating the MathSender
```shell
# In: Components
fprime-util new --component 
```
This command will prompt you for some inputs. Answer the promts as  shown below so components matches the short description above: 

```
[INFO] Cookiecutter source: using builtin
component_name [MyComponent]: MathSender 
component_short_description [Example Component for F Prime FSW framework.]: Active component used for sending operations and operrands to the MathReceiver.
Component_namespace[Component]: MathModule
Select component_kind:
1 - active
2 - passive
3 - queued
Choose from 1, 2, 3 [1]: 1
Select enable_commands:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_telemetry:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_events:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_parameters:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
[INFO] Found CMake file at 'MathProject/project.cmake'
Add component Components/MathSender to MathProject/project.cmake at end of file (yes/no)? yes
Generate implementation files (yes/no)? yes
```


Before doing anything to the files you have just generated, try building:

```shell 
# In: MathSender
fprime-util build
```

> If you have an error here, try running `fprime-util purge` and `fprime-util generate` before building again. 

## Editing the F Prime Prime Model 
Now that you have created the component, you can start working on implementing the component behavior. The first part of implementing component behavior is editting the fpp file. The fpp file will specify what goes into the autogenerated cpp and hpp files. Writing the fpp file will not implement component behavior on its own, but it will generate templates for most of what you will write in cpp and hpp files. 

In `Components/MathSender`, open `MathSender.fpp` and entirely replace its contents with the following: 


@TODO (mathOpOut: MathOp has been refactored to OpRequest)
```fpp
# In: MathSender.fpp
module MathModule {

  @ Component for sending a math operation
  active component MathSender {

    # ----------------------------------------------------------------------
    # General ports
    # ----------------------------------------------------------------------

    @ Port for sending the operation request
    output port mathOpOut: OpRequest

    @ Port for receiving the result
    async input port mathResultIn: MathResult

    # ----------------------------------------------------------------------
    # Special ports
    # ----------------------------------------------------------------------

    @ Command receive port
    command recv port cmdIn

    @ Command registration port
    command reg port cmdRegOut

    @ Command response port
    command resp port cmdResponseOut

    @ Event port
    event port eventOut

    @ Telemetry port
    telemetry port tlmOut

    @ Text event port
    text event port textEventOut

    @ Time get port
    time get port timeGetOut

    # ----------------------------------------------------------------------
    # Commands
    # ----------------------------------------------------------------------

    @ Do a math operation
    async command DO_MATH(
                           val1: F32 @< The first operand
                           op: MathOp @< The operation
                           val2: F32 @< The second operand
                         )

    # ----------------------------------------------------------------------
    # Events
    # ----------------------------------------------------------------------

    @ Math command received
    event COMMAND_RECV(
                        val1: F32 @< The first operand
                        op: MathOp @< The operation
                        val2: F32 @< The second operand
                      ) \
      severity activity low \
      format "Math command received: {f} {} {f}"

    @ Received math result
    event RESULT(
                  result: F32 @< The math result
                ) \
      severity activity high \
      format "Math result is {f}"

    # ----------------------------------------------------------------------
    # Telemetry
    # ----------------------------------------------------------------------

    @ The first value
    telemetry VAL1: F32

    @ The operation
    telemetry OP: MathOp

    @ The second value
    telemetry VAL2: F32

    @ The result
    telemetry RESULT: F32

  }

}
```
> Note: this is an old way of formatting an fpp file but the content is entirely correct.


## About this Component 
 
The above code defines much of the autocoded implementation of  `MathSender`. Generally speaking, while the user defines the types of inputs and outputs, the autocoders handle how the inputs and outputs are dealt with. `MathSender`is **active**, which means it has its
own thread.

Inside the definition of the `MathSender` component are
several specifiers. We have divided the specifiers into five groups. Modern F' will not divide ports into groups like this, however the types of ports are still the same: @TODO (read this)

1. **General ports:** These are user-defined ports for
application-specific functions.
There are two general ports: an output port `mathOpOut`
of type `MathOp` and an input port `mathResultIn` of
type `MathResult`.
Notice that these port specifiers use the ports that
you defined.
The input port is **asynchronous**.
This means that invoking the port (i.e., sending
data on the port) puts a message on a queue.
The handler runs later, on the thread of this component.

2. **Special ports:** These are ports that have a special
meaning in F Prime.
There are ports for registering commands with the dispatcher,
receiving commands, sending command responses, emitting
event reports, emitting telemetry, and getting the time.

3. **Commands:** These are commands sent from the ground
or from a sequencer and dispatched to this component.
There is one command `DO_MATH` for doing a math operation.
The command is asynchronous.
This means that when the command arrives, it goes on a queue
and its handler is later run on the thread of this component.

4. **Events:** These are event reports that this component
can emit.
There are two event reports, one for receiving a command
and one for receiving a result.

5. **Telemetry:** These are **channels** that define telemetry
points that the this component can emit.
There are four telemetry channels: three for the arguments
to the last command received and one for the last
result received.

> For more information on defining components, see
[_The FPP User's Guide_](https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components).


## Generate the Implementation Files

Now you have written the F Prime Prime code for the component, but the cpp and hpp files do not yet reflect the changes you have made to the fpp file. To get the cpp and hpp to reflect the specs you have set fourth in the fpp, you need to use the implement command as shown below and fill in the `MathSender.cpp` and `MathSender.hpp` files: 

```shell
# In: MathSender
fprime-util impl 
```

Now, In `MathSender`, you will see two new files, `MathSender.cpp-template` and `MathSender.hpp-template`. The template files are the files you just generated using the fpp model. Whenever F' generates code, it creates new file with the `-template` so as to not burn down any old code. In this case, you did not write anything in the original `MathSender.cpp` or `MathSender.hpp`, so you can use a move command to replace the old code with the new code:


```shell 
# In: MathSender
mv MathSender.cpp-template MathSender.cpp
mv MathSender.hpp-template MathSender.hpp
```

Build MathSender to make sure everything worked as expected.

```shell 
# In: MathSender 
fprime-util build 
```

## Wait... Shouldn't You Add this to the Build? 

If you've been paying attention to the tutorial thus far, you might be getting some warning bells that you have not added your new component to the build. Fear not, when using `fprime-util new --component` all of the `CMakeLists.txt` and `project.cmake` work was done for you! Take a look at both files to verify for yourself. 

## Conclusion  

You are about two thirds of the way through finishing `MathSender`.
In the next section you will implement `MathSender`'s component 
behavior. 


**Next:** [Creating Components 2](./creating-components-2.md)